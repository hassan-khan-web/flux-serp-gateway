============================= test session starts ==============================
platform linux -- Python 3.13.9, pytest-8.0.0, pluggy-1.5.0
rootdir: /home/mohammed/Flux
plugins: mock-3.12.0, asyncio-0.23.5, cov-7.0.0, anyio-4.10.0
asyncio: mode=Mode.STRICT
collected 118 items

serp-to-context-api/tests/test_coverage_gaps.py ...............          [ 12%]
serp-to-context-api/tests/test_embeddings.py .............               [ 23%]
serp-to-context-api/tests/test_formatter.py .............                [ 34%]
serp-to-context-api/tests/test_parser.py .....                           [ 38%]
serp-to-context-api/tests/test_routes.py FFFF......                      [ 47%]
serp-to-context-api/tests/test_schemas.py ........................       [ 67%]
serp-to-context-api/tests/test_scraper.py ....................           [ 84%]
serp-to-context-api/tests/test_scraper_coverage.py ...........           [ 94%]
serp-to-context-api/tests/test_worker.py .......                         [100%]

=================================== FAILURES ===================================
_______________ TestSearchEndpoint.test_search_endpoint_success ________________

self = <test_routes.TestSearchEndpoint object at 0x7b5073a8b9d0>

    def test_search_endpoint_success(self):
        """Test successful search request creates a task"""
>       with patch("app.api.routes.scrape_and_process.delay") as mock_delay:

serp-to-context-api/tests/test_routes.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../anaconda3/lib/python3.13/unittest/mock.py:1481: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'app.api.routes.scrape_and_process'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
E           AttributeError: module 'app.api.routes' has no attribute 'scrape_and_process'

../anaconda3/lib/python3.13/pkgutil.py:528: AttributeError
____________ TestSearchEndpoint.test_search_endpoint_with_defaults _____________

self = <test_routes.TestSearchEndpoint object at 0x7b5073a8bb10>

    def test_search_endpoint_with_defaults(self):
        """Test search with minimal parameters (uses defaults)"""
>       with patch("app.api.routes.scrape_and_process.delay") as mock_delay:

serp-to-context-api/tests/test_routes.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../anaconda3/lib/python3.13/unittest/mock.py:1481: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'app.api.routes.scrape_and_process'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
E           AttributeError: module 'app.api.routes' has no attribute 'scrape_and_process'

../anaconda3/lib/python3.13/pkgutil.py:528: AttributeError
____________ TestSearchEndpoint.test_search_endpoint_error_handling ____________

self = <test_routes.TestSearchEndpoint object at 0x7b5073965220>

    def test_search_endpoint_error_handling(self):
        """Test error handling in search endpoint"""
>       with patch("app.api.routes.scrape_and_process.delay") as mock_delay:

serp-to-context-api/tests/test_routes.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../anaconda3/lib/python3.13/unittest/mock.py:1481: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'app.api.routes.scrape_and_process'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
E           AttributeError: module 'app.api.routes' has no attribute 'scrape_and_process'

../anaconda3/lib/python3.13/pkgutil.py:528: AttributeError
____________ TestSearchEndpoint.test_search_endpoint_missing_query _____________

self = <test_routes.TestSearchEndpoint object at 0x7b5073965350>

    def test_search_endpoint_missing_query(self):
        """Test validation: query is required"""
>       response = client.post(
            "/search",
            json={
                "region": "us"
            }
        )

serp-to-context-api/tests/test_routes.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../anaconda3/lib/python3.13/site-packages/starlette/testclient.py:546: in post
    return super().post(
../anaconda3/lib/python3.13/site-packages/httpx/_client.py:1145: in post
    return self.request(
../anaconda3/lib/python3.13/site-packages/starlette/testclient.py:445: in request
    return super().request(
../anaconda3/lib/python3.13/site-packages/httpx/_client.py:827: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
../anaconda3/lib/python3.13/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
../anaconda3/lib/python3.13/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
../anaconda3/lib/python3.13/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
../anaconda3/lib/python3.13/site-packages/httpx/_client.py:1015: in _send_single_request
    response = transport.handle_request(request)
../anaconda3/lib/python3.13/site-packages/starlette/testclient.py:348: in handle_request
    raise exc
../anaconda3/lib/python3.13/site-packages/starlette/testclient.py:345: in handle_request
    portal.call(self.app, scope, receive, send)
../anaconda3/lib/python3.13/site-packages/anyio/from_thread.py:291: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
../anaconda3/lib/python3.13/concurrent/futures/_base.py:456: in result
    return self.__get_result()
../anaconda3/lib/python3.13/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
../anaconda3/lib/python3.13/site-packages/anyio/from_thread.py:222: in _call_func
    retval = await retval_or_awaitable
../anaconda3/lib/python3.13/site-packages/fastapi/applications.py:1138: in __call__
    await super().__call__(scope, receive, send)
../anaconda3/lib/python3.13/site-packages/starlette/applications.py:107: in __call__
    await self.middleware_stack(scope, receive, send)
../anaconda3/lib/python3.13/site-packages/starlette/middleware/errors.py:186: in __call__
    raise exc
../anaconda3/lib/python3.13/site-packages/starlette/middleware/errors.py:164: in __call__
    await self.app(scope, receive, _send)
../anaconda3/lib/python3.13/site-packages/starlette/middleware/exceptions.py:63: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
../anaconda3/lib/python3.13/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
../anaconda3/lib/python3.13/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
../anaconda3/lib/python3.13/site-packages/fastapi/middleware/asyncexitstack.py:18: in __call__
    await self.app(scope, receive, send)
../anaconda3/lib/python3.13/site-packages/starlette/routing.py:716: in __call__
    await self.middleware_stack(scope, receive, send)
../anaconda3/lib/python3.13/site-packages/starlette/routing.py:736: in app
    await route.handle(scope, receive, send)
../anaconda3/lib/python3.13/site-packages/starlette/routing.py:290: in handle
    await self.app(scope, receive, send)
../anaconda3/lib/python3.13/site-packages/fastapi/routing.py:124: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
../anaconda3/lib/python3.13/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
../anaconda3/lib/python3.13/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
../anaconda3/lib/python3.13/site-packages/fastapi/routing.py:110: in app
    response = await f(request)
../anaconda3/lib/python3.13/site-packages/fastapi/routing.py:422: in app
    solved_result = await solve_dependencies(
../anaconda3/lib/python3.13/site-packages/fastapi/dependencies/utils.py:653: in solve_dependencies
    solved = await call(**solved_result.values)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi_limiter.depends.RateLimiter object at 0x7b5073a3c440>
request = <starlette.requests.Request object at 0x7b50738e2850>
response = <starlette.responses.Response object at 0x7b5073837380>

    async def __call__(self, request: Request, response: Response):
        if not FastAPILimiter.redis:
>           raise Exception("You must call FastAPILimiter.init in startup event of fastapi!")
E           Exception: You must call FastAPILimiter.init in startup event of fastapi!

../anaconda3/lib/python3.13/site-packages/fastapi_limiter/depends.py:37: Exception
=============================== warnings summary ===============================
serp-to-context-api/app/utils/logger.py:10: 4 warnings
serp-to-context-api/tests/test_coverage_gaps.py: 20 warnings
serp-to-context-api/tests/test_embeddings.py: 28 warnings
serp-to-context-api/tests/test_parser.py: 2 warnings
serp-to-context-api/tests/test_routes.py: 1 warning
serp-to-context-api/tests/test_scraper.py: 8 warnings
serp-to-context-api/tests/test_scraper_coverage.py: 20 warnings
serp-to-context-api/tests/test_worker.py: 15 warnings
  /home/mohammed/Flux/serp-to-context-api/app/utils/logger.py:10: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    "timestamp": datetime.utcnow().isoformat(),

serp-to-context-api/tests/test_worker.py::TestWorkerTask::test_embed_task_with_vectors
serp-to-context-api/tests/test_worker.py::TestWorkerTask::test_embed_task_database_error_logged
  /home/mohammed/Flux/serp-to-context-api/app/worker.py:153: RuntimeWarning: coroutine 'AsyncMockMixin._execute_mock_call' was never awaited
    loop.run_until_complete(init_db())
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED serp-to-context-api/tests/test_routes.py::TestSearchEndpoint::test_search_endpoint_success
FAILED serp-to-context-api/tests/test_routes.py::TestSearchEndpoint::test_search_endpoint_with_defaults
FAILED serp-to-context-api/tests/test_routes.py::TestSearchEndpoint::test_search_endpoint_error_handling
FAILED serp-to-context-api/tests/test_routes.py::TestSearchEndpoint::test_search_endpoint_missing_query
================= 4 failed, 114 passed, 100 warnings in 14.18s =================
